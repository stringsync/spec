# refine

Review and improve specs in the given selector’s scope.

## Inputs
- selector: {{selector}}
  (Either a module name like `foo` or a spec name like `foo.bar`)

## Tools
- Use the `spec.scan` command to quickly find the spec by selector.

## Objective
Evaluate all specs under **{{selector}}** for clarity, scope, and consistency. Where appropriate, split overly-broad specs, merge duplicates, rename confusing spec names, and edit spec content so each spec is precise, testable, and implementable.

## Rules
- Preserve intent of each spec; don’t change behavior unless removing ambiguity.
- Keep spec names stable when possible; if renaming, provide a deterministic mapping.
- Prefer small, composable specs over monoliths.
- Use imperative, verifiable language (e.g. “It must …”).
- Keep each spec self-contained; avoid hidden dependencies.

## Method
1. **Inventory** all specs within {{selector}} and show a quick outline.
2. **Diagnose** issues: ambiguity, dual concerns, duplicates, naming drift, unverifiable language.
3. **Refactor** by proposing: splits, merges, renames, and edits.
4. **Validate** that each resulting spec is atomic, testable, and uniquely named.
5. **Plan migrations** for any renamed spec names.

## Output Format
Markdown with:

### Outline
A tree of specs under {{selector}}.

### Decisions
A bullet list summarizing what changed and why.

### Changes
For each modified spec, include a diff-like fenced block:
```diff
--- before: {{old_path}}
+++ after:  {{new_path}}
- old spec content
+ new spec content
